package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"
)

const wadCfgFileName = "wad.cfg"
const autogenNotice = "// This file has been automatically generated by rigwadcfg. (rigwadcfg will not backup before writing to this file when this line is here)\r\n"
const autogenConfigName = "auto"

var exePathAbs string = ""

func init() {
	log.SetFlags(0)
	var err error
	exePathAbs, err = os.Executable()
	if err != nil {
		log.Fatalf("needed to find location of rigwadcfg executable, but failed: %v.", err)
	}
}

func main() {
	if len(os.Args) != 2 {
		log.Fatal("rigwadcfg needs exactly 1 parameter: path to map file.")
	}
	mapFilePath := os.Args[1]
	mapData, err := ioutil.ReadFile(mapFilePath)
	if err != nil {
		log.Fatalf("could not read '%s': %v.", mapFilePath, err)
	}
	wadFilePaths := sanitizeFilePaths(strings.Split(extractWadString(mapFilePath, mapData), ";"))
	wadCfgFilePath := filepath.Join(filepath.Dir(exePathAbs), wadCfgFileName)
	conditionalBackup(wadCfgFilePath)
	err = ioutil.WriteFile(wadCfgFilePath, []byte(buildWadCfg(autogenConfigName, wadFilePaths)), 0660)
	if err != nil {
		log.Fatalf("writing '%s' failed: %v.", wadCfgFilePath, err)
	}
	log.Printf("wrote %d wad files to 'wad.cfg' using config name '%s'.", len(wadFilePaths), autogenConfigName)
}

func extractWadString(mapFilePath string, mapData []byte) string {
	indentLevel := 0
	inString := false
	previousString := ""
	curString := ""
	stringCount := 0
	eolComment := 0
	for _, r := range mapData {
		if eolComment >= 2 {
		} else if !inString && r == '/' {
			eolComment++
		} else if inString && r != '"' {
			curString += string(r)
		} else if r == '"' {
			if inString {
				if previousString == "wad" && indentLevel == 1 {
					return curString
				}
				previousString = curString
				curString = ""
				stringCount++
			}
			inString = !inString
		} else if r == '{' {
			indentLevel++
		} else if r == '}' {
			indentLevel--
		}
		if (eolComment < 2 && r != '/') || r == '\n' {
			eolComment = 0
		}
	}
	log.Fatalf("could not find wad file paths in '%s': wad-keyvalue pair not found.", mapFilePath)
	return ""
}

func sanitizeFilePaths(filePaths []string) []string {
	sanitizedFilePaths := make([]string, len(filePaths))
	samplePathAbsFirstElement := strings.Split(exePathAbs, string(os.PathSeparator))[0]
	if runtime.GOOS == "windows" {
		if !regexp.MustCompile(`^[a-zA-Z]+\:$`).Match([]byte(samplePathAbsFirstElement)) {
			log.Fatalf("needed to find drive letter in first path element ('%s') of executable path '%s', but there is none.", samplePathAbsFirstElement, exePathAbs)
		}
	}
	for i, filePath := range filePaths {
		filePath = filepath.FromSlash(filePath)
		if runtime.GOOS == "windows" && strings.HasPrefix(filePath, `\`) {
			// Add missing drive letter. Hammer will usually export it like that.
			sanitizedFilePaths[i] = filepath.Join(samplePathAbsFirstElement, filePath)
		} else {
			sanitizedFilePaths[i] = filePath
		}
	}
	return sanitizedFilePaths
}

func buildWadCfg(configName string, wadFilePaths []string) string {
	wadCfg := autogenNotice
	wadCfg += "\r\n"
	wadCfg += configName + "\r\n"
	wadCfg += "{\r\n"
	for _, wadFilePath := range wadFilePaths {
		if strings.Contains(wadFilePath, " ") {
			wadCfg += `"` + wadFilePath + `"` + "\r\n"
		} else {
			wadCfg += wadFilePath + "\r\n"
		}
	}
	wadCfg += "}\r\n"
	return wadCfg
}

func conditionalBackup(filePath string) {
	data, err := ioutil.ReadFile(filePath)
	if os.IsNotExist(err) {
		return
	}
	if err != nil {
		log.Fatalf("could not read file '%s' to decide whether to create a backup of it: %v.", filePath, err)
	}
	if !strings.HasPrefix(string(data), autogenNotice) {
		backupByMove(filePath)
	}
}

func backupByMove(filePath string) {
	filePath = strings.TrimSuffix(filePath, string(os.PathSeparator))
	for i := 1; i <= 999; i++ {
		backupFilePath := fmt.Sprintf("%s.%03d.backup", filePath, i)
		_, err := os.Stat(backupFilePath)
		if os.IsNotExist(err) {
			err = os.Rename(filePath, backupFilePath)
			if err != nil {
				log.Fatalf("tried to rename '%s' to '%s', but failed: %v.", filePath, backupFilePath, err)
			}
			log.Printf("renamed '%s' to '%s'.", filePath, backupFilePath)
			return
		} else if err != nil {
			log.Fatalf("required to check whether file '%s' exists, but failed: %v.", backupFilePath, err)
		}
	}
	log.Fatalf("tried to rename '%s' as a backup, but all backup file names up to and including '%s' appear to be already taken.", filePath, filepath.Base(fmt.Sprintf("%s.999.backup", filePath)))
}
